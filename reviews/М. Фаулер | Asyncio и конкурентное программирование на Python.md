#### Общее впечатление
В целом книга очень даже годная. Помимо самого `asyncio` рассматриваются соседние штуки и концепции, например сокеты, потоки, процессы. Что чем отличается и для каких задач применимо.
Кажется, что было-бы неплохо прочитать книгу второй раз после (или в процессе) того, как буду работать над ассинхронным кодом. 
Есть очень крутые примеры, которые позволяют понять как работает цикл событий asyncio и как он взаимодействует с неблокирующими сокетами и селекторами OS.

#### Заметки на полях
- GIL (стр. 33)
	- В рамках одного процесса блокировка позволяет исполнять в каждый момент времени только одну строку байт-кода, а значит в Python в каждый момент времени  исполняется только один поток (есть исключения, о которых ниже)
- Однопоточная конкурентность (стр. 39)
	- В основе однопоточной конкуретности лежит свойство GIL освобождаться на время ввода-вывода (работа с сетью, файлами и тд.)
- Сокет (стр. 39)
	- Сокеты - это низкоуровневая абстракция операционной системы, через которую происходит отправка и получение данных по сети. Сокет можно сравнить с почтовым ящиком, в него можно положить то, что должно быть отправлено, а также забрать то, что было получено.
- asyncio.wait_for() (стр. 57)
	- позволяет задать тайм-аут для задачи или сопрограммы. По истечению тайм-аута рейзится TimeoutError
- asyncio.gather() (стр. 111)
	- функция, позволяет конкуретно запускать множество задач. Их не нужно перед этим оборачивать через asyncio.create_task(). Недостатком gather является то, что задачи непросто остановить, при необходимости, а также, что результат работы задач можно увидеть только после того, как все они завершаться.
- asyncio.as_completed() (стр. 115)
	- позволяет обрабатывать множество задач, при этом функция возвращает генератор, который на каждой итерации возврает одну завершенную задачу. Недостатком является то, что порядок завершенных задач недетерменирован
- asyncio.wait() (стр. 119)
	- позволяет получить список завершенных (успешно или нет) задач, а также список выполняющихся задач.
- asyncpg
	- ассинхронный драйвер для Postgresql. Также существует подобный драйвер для MySql - aiomysql.
- Пул подключений к БД
	- Одно подключение к БД можно сравнить с одним сокетом, то есть одно подключение может одновременно обрабатывать только один запрос! Пул подключений можно организовывать разными способами: средствами asyncpg или, например, внешними пулерами PgBouncer, Odyssey
- Пулы процессов
	- Для работы с несколькими процессами лучше использовать пул (from multiprocessing import Pool), чем создавать и управлять процессами по-отдельности
- functools.partial
	- Кажется, что довольно полезная функция. Используется для понижения кол-ва аргументов в функции
	  ```python
	  def num_plus_one(num: int) -> int:
		  return num + 1

	  functools.partial(num_plus_one, 2) == 3
	  ```
- MapReduce
	- Подход по разбиению большое объема данный на более мелкие части, для последующей обработки и объединения в исходный вид. 
- Состояние гонки
	- Python сам по себе не потоко-безопасный язык, поэтому у нас существует GIL. Из-за влияние GIL состояние гонки в Python можно словить, когда два или более процесса одновременно модифицируют (неатомарным способом) и читают некие разделяемые данные.
- Атомарные и неатомарные операции в Python
	- прочитать про это можно [здесь](http://mng.bz/5Kj4)
- Критическая секция
	-  Код, который защищается блокировкой, для избежания состояния гонки
- Проблемы синхронизации в модели однопоточной конкуретности
	- Даже в модели однопоточной конкуретности могут возникать возникать проблемы с разделяемыми данными (состояние гонки и тп). Такое может происходить при неверном порядке выполнения шагов (сопрограмм) какой-то большой и сложной задачи и только при модификации разделяемых данных в предложении await.
- Блокировки в asyncio приложениях
	- Блокировку в asyncio следует создавать неподалеку от точки входа в приложение и передавать в вложенные сопрограммы через параметры.

[[Резюме]]
[[Python]]
[[Книги]]
