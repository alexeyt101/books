Общее впечатление:
По-началу показалось, что книга рассчитана на людей, которые никогда не имели дела с SQL и реляционными базами данных. Но на деле это оказалось не так. В книге присутствуют и базовые концепции языка и СУБД PostgreSQL, а также довольно продвинутые, например, уровни изоляции транзакций при конкурентном доступе.
Книга очень годная, имеет много заданий для самостоятельной проработки, а также учебную базу данных со всем необходимым содержимым.

Тезисы с полей:
1. Внешний ключ в реляционной модели не обязан быть уникальным
2. Для столбцов таблицы могут применяться различные ограничения. Кроме широко известного "NOT NULL" могут быть использованы также другие булевы выражения (= > <)
3. Для экранирования кавычек внутри строковых литералов нужно удваивать эти символы. Например `'PGDAY''17'` = PGDAY'17. Также можно использовать удвоенный символ "$". 
4. Формат ввода и вывода дат в PostgreSQL может быть изменен, причем независимо друг от друга. Стандартный формат ввода/вывода: `YYYY-MM-DD`
5. В PostgreSQL существует два типа для времени
	1. `time`
	2. `time with time zone`  - нужно использовать с осторожностью, т.к. не включает дату и из-за этого могут возникать ошибки, особенно при переходе на летнее/зимнее время
6. При попытке удаления строки из ссылочной таблицы (ссылочная - главная, ссылающаяся - второстепенная), по умолчанию, операция удаления будет прервана, если в ссылающейся таблице есть хотя бы одна запись, ссылающаяся на удаляемую строку.
7. Для конвертации значения типа `timestamptz` в значение типа `timestamp` служит конструкция `AT TIME ZONE`
8. Материализованные представления могут использоваться для снижения времени выполнения запроса, особенно сложных. Однако стоит помнить, что для поддержания актуальности данных в таких представлениях их необходимо своевременно обновлять с помощью команды `REFRESH MATERIALIZED VIEW`
9. `Схема базы данных` служит для образования пространства имен в базе данных. В каждой базе данных существует, как минимум, одна схема.
10. Значение `NULL` является особенным и означает отсутствие данных. Это значение не равно никаким другим значениям, в т.ч. самому себе.
11. Если ограничение уникальности (`UNIQUE`) наложено на 2 и более столбца, то при вставке в эти столбцы значений, одно из которых равно `NULL`, то ограничение уникальности работать не будет  из-за `NULL`
12. Команда `SELECT` поддерживает работу с выборками как с множествами:
	1. `UNION` - объединение выборок
	2. `INTERSECT` - пересечение выборок
	3. `EXCEPT` - разность выборок
13. Оконные функции (`windows functions`) - это такие инструменты, которые позволяют проводить какие-либо вычисления на подмножестве строк выборки, которые объединяются с текущей строкой каким-то логическим условием. Такие функции позволяют, например, вычислять `rank` или реализовывать различные счетчики.
14. Оконные функции имеют два внутренних параметра:
	1. `раздел` - множество строк, которые объединяются каким-то одинаковым значением (значение какого-либо столбца)
	2. `кадр` - множество строк внутри раздела. эти строки определяются по-разному в зависимости от того, отсортирован раздел или нет. Например, если раздел отсортирован по какому-то столбцу, то в оконный кадр включаются все строки от начала раздела до текущей строки
15. Подзапросы могут присутствовать в след. выражениях:
		1. `SELECT`
		2. `FROM`
		3. `WHERE`
		4. `HAVING`
		5. `WITH`
16. Подзапросы можно выделять в отдельную конструкцию - `Common Table Expressions (CTE)`. С помощью этого выражения можно избежать дублирования кода и обращаться из основного запроса к какому-то общему коду несколько раз
17. Функции `COUNT` можно передавать параметры. Например, `DISTINCT` для подсчета только уникальных значений
18. PostgreSQL поддерживает временный таблицы, которые существуют только до времени завершения сеанса. Такие таблицы удобны для экспериментов. Их можно создавать с копированием данных или с копированием только схемы таблицы. `CREATE TEMP TABLE` и `CREATE TEMP TABLE WITH NO DATA`
19. Для учета изменений в таблицах (кто и когда изменил данные) следует использовать триггеры (`triggers`) и правила (`rules`)
20. В команду `INSERT` можно добавлять выражение `ON CONFLICT`, которое позволяет по-разному обрабатывать конфликты при вставке
21. В PostgreSQL существует команда `COPY`, которая позволяет писать данные из таблицы в файл и наоборот
22. Транзакции
	1. Транзакции в PostgreSQL основаны на модели MVCC. Это модель предполагает, что каждый SQL оператор "видит" снимок данных, другими словами, то согласованное состояние базы данных, которая она имела в определенный момент времени
	2. Важным свойством MVCC является то, что операции записи не блокируют операции чтения и наоборот
	3. ACID - это свойства транзакций
		1. атомарность (`atomic`) - транзакция фиксируется либо полностью, либо не фиксируется вовсе
		2. согласованность (`consistency`) - транзакция переводит БД из одного согласованного состояния в другое
		3. изолированность (`isolation`) - во время выполнения транзакции другие транзакции должны оказывать на неё минимальное влияние
		4. устойчивость (`durability`) - после фиксации транзакции пользователь должен быть уверен, что его данные будут на месте, даже если произойдет сбор СУБД.
	4. При параллельном выполнении транзакций возможны след. аномалии чтения:
		1. Потерянное обновление (`lost update`). Когда две транзакции обновляют одни и те же данные, то после фиксации изменений может оказаться, что одна транзакция перезаписала данные, сохраненные другой транзакцией
		2. "Грязное чтение" (`dirty read`). Транзакция читает данные, сделанные параллельной транзакцией, которая еще не завершилась. Если эта параллельная транзакция будет отменена, тогда окажется, что первая транзакция прочитала данные, которых нет в системе
		3. Неповторяющееся чтение (`unrepeatable read`). При повторном чтении тех же самых данных в рамках одной транзакции оказывается, что другая транзакция успела изменить и зафиксировать эти данные. В результате тот же самый запрос выдает другой результат.
		4. Фантомное чтение (`phantom read`). Транзакция повторно выбирает некоторое количество строк в соответствии с прежним критерием. В интервале времени между выполнением этих двух выборок другая транзакция добавляет новые строки и успешно фиксирует изменения. В результате при выполнении повторной выборки в первой транзакции может быть получено другое множество строк.
		5. Аномалия сериализации (`serialization anomaly`). Результат выполнения группы транзакций, выполняющихся параллельно, не совпадает с результатов ни одного из возможных результатов упорядочения этих транзакций, если бы они выполнялись последовательно. 
	5. Уровни изоляции транзакций SQL:
		1. `Read Uncommitted`. Это самый низкий уровень изоляции. Согласно стандарту SQL на этом уровне допускается чтение "грязных" данных. Однако в PostgreSQL требования, предъявляемые к этому уровню выше: чтение "грязных" данных не допускается.
		2. `Read Committed`. Не допускается чтение "грязных" данных. Таким образом в PostgreSQL уровень `Read Uncommited` совпадает с этим уровнем. Транзакция может видеть только те незафиксированные данные, которые сделаны её самой. **В PostgreSQL является уровнем по умолчанию.**
		3. `Repeatable Read`. Не допускается чтение "грязных" данных и неповторяющееся чтение. В PostgreSQL на этом уровне также не допускается фантомное чтение.
		4. `Serializable`. Не допускается ни один из феноменов, перечисленных выше, а также аномальная сериализация.
23. Методы доступа к данным:
	1. Последовательный просмотр
	2. Просмотр на основе индекса
	3. Просмотр исключительно на основе индекса
	4. Просмотр на основе битовой карты
24. Перед выполнением каждого запроса PostgreSQL стоит план выполнения. Этим занимается отдельная подсистема - Планировщик запросов.
25. С помощью команды `EXPLAIN` можно просматривать и анализировать план запроса
26. C помощью `EXPLAIN ANALYZE` можно анализировать план запроса и параметры фактического его выполнения
27. Нельзя экстраполировать оценки и выводы, полученные для запроса к таблице маленького размера, на таблицы большого размера и наоборот. Это связано с тем, что оценки планировщика нелинейны. 

[[Книги]]
[[Резюме]]
[[SQL]]