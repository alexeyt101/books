### Общее впечатление
Книга представляет собой каталог паттернов проектирования с подробным описанием каждого паттерна.
Особенно понравилось, что подробно описана область применения паттернов и какую проблему они решают.
Книга видится очень полезной не только при проектировании новых систем, но и при решении проблем в
существующих.
Создалось впечатление, что осознать материал книги с первого раза не представляется возможным,
и авторы это подтверждают.
Однозначно буду перечитывать где-нибудь через годик

### Заметки о паттернах
Для удобства работы с материалами книги хочется вынести основную информацию по некоторым паттернам в резюме.
Приведу проблему, которую решают паттерны и когда их стоит применять.

#### 1 Абстрактная фабрика (Abstract Factory)
**Назначение**

Представляет интерфейс для создания **семейств** взаимосвязанных или взаимозависимых объектов,
не специфицируя их конкретные классы.
В интерфейсе фабрики есть операции для создания каждого вида объектов из семейства.
Клиент вызывает их для получения объектов, не зная при этом объекты какого класса получает.

**Применимость**
* система не должна зависеть от того, как создаются, компонуются и представляются входящие в неё объекты;
* система должна настраиваться одним из семейств объектов;
* входящие в семейство взаимосвязанные объекты спроектированы для совместной работы, и вы должны обеспечить
выполнение этого ограничения;
* вы хотите предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию.


#### 2 Строитель (Builder)
**Назначение**

Отделяет конструирование сложного объекта от его представления, так что в результате одного и того же конструирование
могут получаться разные представления.
Конструирование происходит поэтапно и под контролем клиента, при этом информация о том из каких частей состоит сложный
объект и как эти части скомпонованы для клиента недоступна.

**Применимость**
* алгоритм создания сложного объекта не должен зависеть от как и из каких частей состоит объект и как они стыкуются между  собой;
* процесс конструирования должен обеспечивать различные представления сложного объекта.

#### 3 Фабричный метод (Factory Method)
**Назначение**

Определяет интерфейс для создания объекта, но оставляет подклассам решение о том, экземпляры какого класса
должны создаваться. Фабричный метод позволяет классу делегировать создания экземпляров подсклассам.

**Применимость**
* классу заранее неизвестно, объекты какого класса ему нужно создавать;
* класс спроетирован так, чтобы объекты, которые он создает, определялись в подклассах;
* класс делегирует свои обязанности одному из нескольких вспомогательных подклассов , и вам нужно локализовать
информацию о то* классу заранее неизвестно, объекты какого класса ему нужно создавать;
* класс спроетирован так, чтобы объекты, которые он создает, определялись в подклассах;
* класс делегирует свои обязанности одному из нескольких вспомогательных подклассов , и вам нужно локализовать
информацию о том, какой класс будет принимать эти обязанности на себя.

#### 4 Прототип (Prototype)
**Назначение**

Задает виды создаваемых объектов с помощью экземпляра-прототипа и создает новые объекты путем копирования
этого прототипа.

**Применимость**
* классы для создания экземпляров определяются во время выполениня; *или*
* для того, чтобы избежать построение иерархий классов или фабрик, параллельных иерархий классов продукта; *или*
* экземпляры класса могут находится в одном из не очень большого числа различных состояний. Может быть удобно установить
соответствующее число прототипов и клонировать их, а не создавать экземпляр в подходящем состоянии каждый раз вручную.

#### 5 Одиночка (Singleton)
**Назначение**

Гарантирует, что у класса существует только один экземпляр, и предоствляет к нему глобальную точку доступа.

**Применимость**
* должен существовать только один экземпляр некоторого класса, к которому может обратиться любой клиент через известную точку доступа;
* единственный экземпляр должен расширяться путем порождения подклассов, а клиенты должны иметь возможность работать с расширенным экземпляром без модификации своего кода.

#### 6 Цепочка обязанностей (Chain of responsibility)
**Назначение**

Позволяет избежать привязки отправителя запроса к его получателю, предоставляя возможность обработать запрос нескольки объектам. Связаывает объекты-получатели в цепочку и передает запрос по этой цепочке, пока он не будет обработан.

**Применимость**
* запрос может быть обработан более чем одним объектом, при чем настроящий обработчик заранее неизвестен и должен быть найден автоматически;
* запрос должен быть отправлен одному из нескольких объектов, без явного указания, какому именно;
* набор объектов, способных обработать запрос, должен задаваться динамически.

#### 7 Команда (Command)
**Назначение**

Инкапсулирует запросы в объекты, позволяя тем самым параметризовать клиенты для разных запросов, ставить запросы в очередь или протоколировать их, а также поддерживать отмену операции

**Применимость**
* параметризация объектов выполняемым действием. Команды представляют объектно-ориентированную альтернативу функциям обратного вызова, т.е. функциям, которые могут быть вызваны когда-то позднее;
* определение, постановка в очередь и выполнение запрсов в разное время. Время жизни объекта команды не обязательно должно зависеть от времени жизни исходного запроса;
* поддержка отмены операций.

#### 8 Посредник (Mediator)
**Назначение**

Определяет объект, инкапсулирующий способ взаимодействия множества объектов. Посредник обеспечивает слабую связность системы, избавляя объекты от необходимости явно ссылаться друг на друга и позволяя тем самым независимо изменять взаимодействия между ними.

**Применимость**
* существование объектов, связи между которыми сложны, но при этом четко определены. Получающиеся при этом взаимозависимости не структурированы и сложны для понимания;
* повторное использование объекта затруднено, поскольку он обменивается информацией со многими другими объектами;
* поведение, разделенное между несколькими классами, должно настраиваться без порождения множества подклассов.


#### 9 Хранитель (Memento)
**Назначение**

Не нарушая инкапсуляции, фиксирует и выносит за пределы объекта его внутреннее состояние, так чтобы позднее можно было восстановить в нем объект.

**Применимость**
* необъодимость сохранения снимка состояния объекта (или его части), чтобы вспоследствии объект можно было восстановить в том же состоянии; и
* прямой интерфейс для получения этого состояния привел бы к раскрытию подробностей реализации и нарушению инкапсуляции объекта.

#### 10 Наблюдатель (Observer)
**Назначение**

Определяет зависимость "один ко многим" между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом и автоматически обновляются.

**Применимость**
* у абстракции есть два аспекта, один из которых зависит от другого. Инкапсуляция этих аспектов в разных объектах позволяет изменять и повторно использовать их независимо;
* при модификации одного объекта требуется изменить другие, и вы не знаете сколько именно объектов нужно изменить;
* один объект должен оповещать других, не делая предположений об уведомляемых объектах. Другими словами, объекты не должны быть тесно связаны между собой.

#### 11 Состояние (State)
**Назначение**

Позволяет объекту изменять свое поведение в зависимости от внутреннего состояния. Извне создается впечатление, что изменился класс объекта.

**Применимость**
* поведение объекта зависит от его состояния и должно изменяться во время выполнения;
* когда в коде операций встречаются состоящие из многих ветвей условные операторы, в которых выбор ветви зависит от состояния. Обычно в таком случае состояние представлено перечисляемыми константами. Часто одна и та же структура условного оператора повторяется в нескольких операциях. Паттерн "состояние" предлагает поместить каждую ветвь в отдельный класс. Это позволяет трактовать состояние объекта как самостоятельный объект, который может изменяться независимо от других.

#### 12 Стратегия (Strategy)
**Назначение**

Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. "Стратегия" позволяет изменять алгоритмы независимо от клиентов, которые ими пользуются.

**Применимость**
* наличие множества родственных классов, которые отличаются только поведением;
* наличие нескольких разновидностей алгоритма. Например, можно определить два варианта алгоритма, один из которых требует больше времени, а другой больше памяти. "Стратегии" разрешается применять, когда варианты алгоритма реализованы в виде иерархии классов;
* в алгоритме используются данные, о которых клиент не должен "знать". Можно использвать "стратегию", чтобы инкапсулировать сложные стркутуры данных алгоритма;
* в классе определено много вариантов поведения, представленных разветвленными условными операторами. В этом случае можно перенести код из каждой ветки в отдельные классы-стратегии.

[[Архитектура ПО]]
[[Резюме]]
[[Книги]]

